Ongoing tasks in order of priority:

- Action phase:
	- Refine playable options, and receive choice by user, define series of errors of play (I.e. can't afford, etc, too many targets)
		- Function to check play options for a card
			- Extract card data
			- Tell you OK_PLAYABLE and where
			- Or error code regarding not playable (see below)
		- When attempting to play from hand, playc card#, in lane X:
			- Verify if power of 2 or 0 (x & x-1 == 0)
			- Extract card data
			- Verify gold
			- Verify real (where it _can_ be played), could be optimized but not needed most likely
			- If all checks are ok, perform action, otherwise return error and null
		- Either override or extend CardGetter to be able to return test cards.
			- Cards number 00 to -99 -> Playable bricks, procedurally created as G-TGT, gold cost and target, effect, none
			- Cards number -01111 to -99999 -> Playable token units, procedurally generated as G-HP-ATK-MVT-DEN
			- Cards number -100000000 to -199999999 -> Playable token buildings, procedurally generated as 1-G-HP-[bPlain-bForest-bMountain](packed 18-bit binary, 4-6-8bit)
		- New system tests, based on CardPlayabilityTest, checking if can afford, etc
	- Design action request (play X card, target), remake targets to flagged enum and make function that returns a flagged enum of valid targets
	- Step, and return effect
	- Rush as special case, add rush flag, which secretly is playing a card, flag is cleaned at EOT as new event
- Board:
	- Implementing units and buildings as part of previous task, extend to basic board permanence
	- Board test, eventually will become one of the main tests regarding combat and overall board state
- EOT phase:
	- Transistion to next player (no EOT eff for now)
	- Start thinking about marching, and tiredness flags, attacking, stepping, starting march, etc
- Implement rest of rulebook
	- Todo...
	- Lots of individual mechanics that will be polished as it goes, individual card testing