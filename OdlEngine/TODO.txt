Ongoing tasks in order of priority:
- Stealth
	- Rework Lane/Tile as members of the same "PhysicalLocation" class. Number of units, stealth units, Mantain list of units. They just duplicate info. Hash of lane is just hash of tiles (dependence). Methods: Insert (unit/building), GetRealNumber. Serialization tbd but most likely all? Or just some idk. Check if I want to also define list for all players, or both, no shame on having lots of info. 
	- Think it properly as stealth buildings stack!
		- May require multiple building in tile for this case,
		- Lots of complex correlations, make sure to think of possibilities for:
			- Unit w stealth building
			- Stealth unit w building
			- Stealth unit w stealth building
			- Stealth building position(s) and proper correlations
			- Discovery loop
			- Advancement and stealth, better handling of advancement context (not just clear if unit)
			- Discovery events? Combat discovers, (later there'll be other ones)
	- Stealth test cases:
		- Stealth unit
		- Stealth building:
			- many summoned depending on buildability
		- Stealth correlation, when unit is revealed:
			- All negatives result in a discovery
			- A positive discovers all
		- Stealth unit revealed by pre combat
		- Stealth building revealed by pre-combat
		- Stealth building stacking
		- Stealth character construction, multiple cases
- Implement complex effects:
	- Events (when an effect occurs globally and triggers a unit, e.g. EOT). Loaded as dict <EventType, List<Entity>> of entities with the effect. This can be serialized, non-hashed.
	- Filters?
	---
	- Buff tokens
	- Buff tok is just extra fields (hashable and serializable) on the placeable
- Implement rest of rulebook
	- Procedure:
		- Propose card, way to code it
		- Add triginters if not there already
		- Ask yourself questions of how it could break the game, how it affects stealth, probably triginter related but good excercise
		- No individual card testing! Game must be mechanically robust even if cards are completely revamped
